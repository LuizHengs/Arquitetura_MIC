Info: Start Nativelink Simulation process

========= EDA Simulation Settings =====================

Sim Mode              :  Gate
Family                :  cyclonev
Quartus root          :  /opt/intelFPGA_lite/24.1std/quartus/linux64/
Quartus sim root      :  /opt/intelFPGA_lite/24.1std/quartus/eda/sim_lib
Simulation Tool       :  questa intel fpga
Simulation Language   :  vhdl
Version               :  93
Simulation Mode       :  GUI
Sim Output File       :  MIC_1.vho
Sim SDF file          :  MIC_1__vhdl.sdo
Sim dir               :  simulation/questa

=======================================================

Info: Starting NativeLink simulation with Questa Intel FPGA software
Sourced NativeLink script /opt/intelFPGA_lite/24.1std/quartus/common/tcl/internal/nativelink/modelsim.tcl
Warning: File MIC_1_run_msim_gate_vhdl.do already exists - backing up current file as MIC_1_run_msim_gate_vhdl.do.bak7
Probing transcript
Questa Intel FPGA Info: # //  Questa Intel Starter FPGA Edition-64
Questa Intel FPGA Info: # //  Version 2024.3 linux_x86_64 Sep 10 2024
Questa Intel FPGA Info: # //
Questa Intel FPGA Info: # // Unpublished work. Copyright 2024 Siemens
Questa Intel FPGA Info: # //
Questa Intel FPGA Info: # // This material contains trade secrets or otherwise confidential information
Questa Intel FPGA Info: # // owned by Siemens Industry Software Inc. or its affiliates (collectively,
Questa Intel FPGA Info: # // "SISW"), or its licensors. Access to and use of this information is strictly
Questa Intel FPGA Info: # // limited as set forth in the Customer's applicable agreements with SISW.
Questa Intel FPGA Info: # //
Questa Intel FPGA Info: # // This material may not be copied, distributed, or otherwise disclosed outside
Questa Intel FPGA Info: # // of the Customer's facilities without the express written permission of SISW,
Questa Intel FPGA Info: # // and may not be used in any way not expressly authorized by SISW.
Questa Intel FPGA Info: # //
Questa Intel FPGA Info: # do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Copying /opt/intelFPGA_lite/24.1std/questa_fse/linux_x86_64/../modelsim.ini to modelsim.ini
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:18:23 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:18:23 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:18:29 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:18:29 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:18:29 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-3812) Design is being optimized...
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_ena.do
Questa Intel FPGA Info: # ===== stim_debug_ena.do =====
Questa Intel FPGA Info: # Verifica se ENA realmente zera a perna A da ULA.
Questa Intel FPGA Info: # Caso ENA=0 e Y ainda dependa de A, sua ULA precisa mascarar A.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} { array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}; bsel_none; force -deposit $::TOP/bsel_oh($IDX($src)) 1 }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ULA modes (iguais aos seus)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre Y e C automaticamente
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {$::YSIG eq ""} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YSIG]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---------- Sequência ----------
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Zera H e PC de forma síncrona (1 ciclo cada)
Questa Intel FPGA Info: # ula ZERO; bsel H;  force -deposit $TOP/enH  1; step 1; force -deposit $TOP/enH  0
Questa Intel FPGA Info: # ula ZERO; bsel H;  force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Carrega H <- 1 (para testar o vazamento de A)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # Estado agora: H=1, PC=0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso A: B_PLUS_1 canônico (ENA=0). A deve ser ignorado. Esperado Y=1 (0 + 1).
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ENA=0, A=1, B=0, INC=1  -> Y deve ser 1"
Questa Intel FPGA Info: # PASS ENA=0, A=1, B=0, INC=1  -> Y deve ser 1 -> Y=00000001
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso B: mesma coisa, mas com ENA=1 (A+B+1). Esperado Y=2.
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "ENA=1, A=1, B=0, INC=1  -> Y deve ser 2"
Questa Intel FPGA Info: # PASS ENA=1, A=1, B=0, INC=1  -> Y deve ser 2 -> Y=00000002
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # echo ">> Se o primeiro teste (ENA=0) deu 2, a perna A não está sendo zerada quando ENA=0."
Questa Intel FPGA Info: # >> Se o primeiro teste (ENA=0) deu 2, a perna A não está sendo zerada quando ENA=0.
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate.do (checa C e Y; PC+1 corrigido) =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # -------- clock 10 ns (50% duty) --------
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # -------- helpers --------
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc bsel_none {} {
Questa Intel FPGA Info: #   for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     A_AND_B  {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_OR_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # -------- localizar C-bus (Cprobe/Cbus) e Yprobe --------
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # normalização de hex
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]
Questa Intel FPGA Info: #   set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} {
Questa Intel FPGA Info: #     echo "PASS $msg (Z=$z N=$n)"
Questa Intel FPGA Info: #   } else {
Questa Intel FPGA Info: #     echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)"
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # -------- reset --------
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1
Questa Intel FPGA Info: # step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0
Questa Intel FPGA Info: # step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ========== TESTES ==========
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) TOS <- 2 (MBRs)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) MDR <- 3 (READ)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1
Questa Intel FPGA Info: # force -deposit $TOP/enH 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) TOS <- H + MDR => 5
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000005 "H + MDR"
Questa Intel FPGA Info: # PASS H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) PC <- 0 e depois PC <- PC + 1  (com ciclo idle para assentar)
Questa Intel FPGA Info: # ula ZERO
Questa Intel FPGA Info: # force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0         ;# H=0
Questa Intel FPGA Info: # bsel H; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0        ;# PC=0
Questa Intel FPGA Info: # clear_ctrl; step 1                                                     ;# idle
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1"
Questa Intel FPGA Info: # FAIL Y = PC + 1 -> got 00000002 expected 00000001
Questa Intel FPGA Info: # expect_c 00000001 "PC + 1"
Questa Intel FPGA Info: # FAIL PC + 1 -> got 00000002 expected 00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) SLL8 (TOS <<= 8) -> C=0x00000500, Y deve ser 0x00000005
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # FAIL Y antes do shift (TOS=5) -> got 00000500 expected 00000005
Questa Intel FPGA Info: # expect_c 00000500 "SLL8 (5 << 8)"
Questa Intel FPGA Info: # FAIL SLL8 (5 << 8) -> got 00050000 expected 00000500
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) SRA1: -4 >> 1 => -2  (Y=-4, C=-2)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # FAIL Y antes do shift (-4) -> got fffffffe expected fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "SRA1(-4)"
Questa Intel FPGA Info: # FAIL SRA1(-4) -> got ffffffff expected fffffffe
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0; force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 330 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos."
Questa Intel FPGA Info: # >> Testes concluídos.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do scan_bsel_mbrs.do
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # clock/reset curto
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; run 30 ns
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; run 10 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ULA e shifter neutros
Questa Intel FPGA Info: # force -deposit $TOP/F0 0; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; force -deposit $TOP/ENB 1
Questa Intel FPGA Info: # force -deposit $TOP/INVA 0; force -deposit $TOP/INC 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # carrega MBR=0x02
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; run 10 ns; force -deposit $TOP/FETCH 0; run 5 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Bprobe no topo?
Questa Intel FPGA Info: # set HAVE_BPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [find signals -r $TOP/*Bprobe*]
Questa Intel FPGA Info: # /mic1_draw/ww_Bprobe /mic1_draw/Bprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set BPROBE [lindex $CANDS 0]; set HAVE_BPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # echo "---- varrendo bsel_oh com MBR=0x02 ----"
Questa Intel FPGA Info: # ---- varrendo bsel_oh com MBR=0x02 ----
Questa Intel FPGA Info: # for {set i 0} {$i<10} {incr i} {
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $TOP/bsel_oh($i) 1
Questa Intel FPGA Info: #   run 2 ns
Questa Intel FPGA Info: #   set z [examine $TOP/Z]
Questa Intel FPGA Info: #   if {$::HAVE_BPROBE} { set bp [examine -radix hex $BPROBE]; echo "bsel_oh($i)=1 -> Bprobe=$bp  Z=$z" } else { echo "bsel_oh($i)=1 -> Z=$z" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # bsel_oh(0)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(1)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(2)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(3)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(4)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(5)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(6)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(7)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(8)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(9)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # echo "Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu)."
Questa Intel FPGA Info: # Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu).
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:19:41 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:19:41 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:19:42 on Aug 23,2025, Elapsed time: 0:01:13
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:19:42 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_pc.do
Questa Intel FPGA Info: # ===== stim_debug_pc.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} { array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}; bsel_none; force -deposit $::TOP/bsel_oh($IDX($src)) 1 }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset e zera H/PC
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # PC + 1 (B = PC, ENA=0)
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; force -deposit $TOP/enPC 1; step 1
Questa Intel FPGA Info: # set y [examine -radix hex $TOP/Yprobe]
Questa Intel FPGA Info: # 00000X0X
Questa Intel FPGA Info: # set c [lindex [concat [examine -radix hex [lindex [find signals -r $TOP/*Cprobe*] 0]] [examine -radix hex [lindex [find signals -r $TOP/*Cbus*] 0]]] 0]
Questa Intel FPGA Info: # ** UI-Msg (Error): (vish-4014) No objects found matching ''.
Questa Intel FPGA Info: # Executing ONERROR command at macro ./stim_debug_pc.do line 27
Questa Intel FPGA Info: # echo "PC+1 -> Y=$y  C=$c (esperado 00000001)"
Questa Intel FPGA Error: # ** Error: can't read "c": no such variable
Questa Intel FPGA Info: # Executing ONERROR command at macro ./stim_debug_pc.do line 28
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Se sair 00000002, revise a ULA: A_gated <= (others=>'0') quando ENA='0'.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_debug_ena.do
Questa Intel FPGA Info: # ===== stim_debug_ena.do =====
Questa Intel FPGA Info: # Verifica se ENA realmente zera a perna A da ULA.
Questa Intel FPGA Info: # Caso ENA=0 e Y ainda dependa de A, sua ULA precisa mascarar A.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} { array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}; bsel_none; force -deposit $::TOP/bsel_oh($IDX($src)) 1 }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ULA modes (iguais aos seus)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre Y e C automaticamente
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {$::YSIG eq ""} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YSIG]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---------- Sequência ----------
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Zera H e PC de forma síncrona (1 ciclo cada)
Questa Intel FPGA Info: # ula ZERO; bsel H;  force -deposit $TOP/enH  1; step 1; force -deposit $TOP/enH  0
Questa Intel FPGA Info: # ula ZERO; bsel H;  force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Carrega H <- 1 (para testar o vazamento de A)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # Estado agora: H=1, PC=0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso A: B_PLUS_1 canônico (ENA=0). A deve ser ignorado. Esperado Y=1 (0 + 1).
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ENA=0, A=1, B=0, INC=1  -> Y deve ser 1"
Questa Intel FPGA Info: # PASS ENA=0, A=1, B=0, INC=1  -> Y deve ser 1 -> Y=00000001
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso B: mesma coisa, mas com ENA=1 (A+B+1). Esperado Y=2.
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "ENA=1, A=1, B=0, INC=1  -> Y deve ser 2"
Questa Intel FPGA Info: # PASS ENA=1, A=1, B=0, INC=1  -> Y deve ser 2 -> Y=00000002
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # echo ">> Se o primeiro teste (ENA=0) deu 2, a perna A não está sendo zerada quando ENA=0."
Questa Intel FPGA Info: # >> Se o primeiro teste (ENA=0) deu 2, a perna A não está sendo zerada quando ENA=0.
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v3.do (C e Y checados corretamente) =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- clock 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus) e Yprobe ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- reset ----
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) TOS <- 2 (MBRs)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) MDR <- 3
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1
Questa Intel FPGA Info: # force -deposit $TOP/enH 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) TOS <- H + MDR => 5
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000005 "H + MDR"
Questa Intel FPGA Info: # PASS H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) PC <- 0 e depois PC <- PC + 1  (zera H e PC antes para não contaminar A)
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; step 1
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1"
Questa Intel FPGA Info: # FAIL Y = PC + 1 -> got 00000002 expected 00000001
Questa Intel FPGA Info: # expect_c 00000001 "PC + 1"
Questa Intel FPGA Info: # FAIL PC + 1 -> got 00000002 expected 00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) SLL8 (TOS <<= 8)  -> Y=00000005 (pré), C=00000500 (pós)
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # FAIL Y antes do shift (TOS=5) -> got 00000500 expected 00000005
Questa Intel FPGA Info: # expect_c 00000500 "SLL8 (5 << 8)"
Questa Intel FPGA Info: # FAIL SLL8 (5 << 8) -> got 00050000 expected 00000500
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) SRA1: -4 >> 1 => -2  (Y=-4, C=-2)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1; force -deposit $TOP/enTOS 1; step 1
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # FAIL Y antes do shift (-4) -> got fffffffe expected fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "SRA1(-4)"
Questa Intel FPGA Info: # FAIL SRA1(-4) -> got ffffffff expected fffffffe
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0; force -deposit $TOP/enTOS 0; bsel_none; clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 393 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v3)."
Questa Intel FPGA Info: # >> Testes concluídos (v3).
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do scan_bsel_mbrs.do
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # clock/reset curto
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; run 30 ns
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; run 10 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ULA e shifter neutros
Questa Intel FPGA Info: # force -deposit $TOP/F0 0; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; force -deposit $TOP/ENB 1
Questa Intel FPGA Info: # force -deposit $TOP/INVA 0; force -deposit $TOP/INC 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # carrega MBR=0x02
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; run 10 ns; force -deposit $TOP/FETCH 0; run 5 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Bprobe no topo?
Questa Intel FPGA Info: # set HAVE_BPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [find signals -r $TOP/*Bprobe*]
Questa Intel FPGA Info: # /mic1_draw/ww_Bprobe /mic1_draw/Bprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set BPROBE [lindex $CANDS 0]; set HAVE_BPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # echo "---- varrendo bsel_oh com MBR=0x02 ----"
Questa Intel FPGA Info: # ---- varrendo bsel_oh com MBR=0x02 ----
Questa Intel FPGA Info: # for {set i 0} {$i<10} {incr i} {
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $TOP/bsel_oh($i) 1
Questa Intel FPGA Info: #   run 2 ns
Questa Intel FPGA Info: #   set z [examine $TOP/Z]
Questa Intel FPGA Info: #   if {$::HAVE_BPROBE} { set bp [examine -radix hex $BPROBE]; echo "bsel_oh($i)=1 -> Bprobe=$bp  Z=$z" } else { echo "bsel_oh($i)=1 -> Z=$z" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # bsel_oh(0)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(1)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(2)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(3)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(4)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(5)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(6)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(7)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(8)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(9)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # echo "Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu)."
Questa Intel FPGA Info: # Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu).
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:24:08 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:24:08 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:24:09 on Aug 23,2025, Elapsed time: 0:04:27
Questa Intel FPGA Info: # Errors: 1, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:24:09 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v4.do =====
Questa Intel FPGA Info: # Sequência de testes do MIC-1 (gates) medindo Y/C ANTES do flanco de clock.
Questa Intel FPGA Info: # Assim evitamos ler o valor recombinado depois da escrita do registrador.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # ULA (Figura 4.2)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus) e Yprobe ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) TOS <- 2 (MBRs)  --- mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) MDR <- 3
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) TOS <- H + MDR => 5  --- mede ANTES do flanco
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000005 "H + MDR"
Questa Intel FPGA Info: # PASS H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) PC <- 0 e depois PC <- PC + 1
Questa Intel FPGA Info: # zera H e PC primeiro
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1;  step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # mede Y combinacional (PC + 1) ANTES do flanco
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # grava PC <- PC+1 no flanco; depois limpa para não recombinar para 2
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # Se quiser, confirme que PC armazenou 1:
Questa Intel FPGA Info: # bsel PC; ula PASS_B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) SLL8 (TOS <<= 8)
Questa Intel FPGA Info: # mede Y (pré-shift) e C (pós-shift) ANTES de gravar em TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # agora grava TOS <- Q e limpa
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) SRA1: -4 >> 1 => -2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 252 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v4)  agora as medições são feitas antes do flanco."
Questa Intel FPGA Info: # >> Testes concluídos (v4)  agora as medições são feitas antes do flanco.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do scan_bsel_mbrs.do
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # clock/reset curto
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; run 30 ns
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; run 10 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ULA e shifter neutros
Questa Intel FPGA Info: # force -deposit $TOP/F0 0; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; force -deposit $TOP/ENB 1
Questa Intel FPGA Info: # force -deposit $TOP/INVA 0; force -deposit $TOP/INC 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0; force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # carrega MBR=0x02
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; run 10 ns; force -deposit $TOP/FETCH 0; run 5 ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Bprobe no topo?
Questa Intel FPGA Info: # set HAVE_BPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [find signals -r $TOP/*Bprobe*]
Questa Intel FPGA Info: # /mic1_draw/ww_Bprobe /mic1_draw/Bprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set BPROBE [lindex $CANDS 0]; set HAVE_BPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # echo "---- varrendo bsel_oh com MBR=0x02 ----"
Questa Intel FPGA Info: # ---- varrendo bsel_oh com MBR=0x02 ----
Questa Intel FPGA Info: # for {set i 0} {$i<10} {incr i} {
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $TOP/bsel_oh($i) 1
Questa Intel FPGA Info: #   run 2 ns
Questa Intel FPGA Info: #   set z [examine $TOP/Z]
Questa Intel FPGA Info: #   if {$::HAVE_BPROBE} { set bp [examine -radix hex $BPROBE]; echo "bsel_oh($i)=1 -> Bprobe=$bp  Z=$z" } else { echo "bsel_oh($i)=1 -> Z=$z" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # bsel_oh(0)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(1)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(2)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(3)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(4)=1 -> Bprobe=00000002  Z=0
Questa Intel FPGA Info: # bsel_oh(5)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(6)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(7)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(8)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_oh(9)=1 -> Bprobe=00000000  Z=1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # echo "Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu)."
Questa Intel FPGA Info: # Dica: indice com Z=0 e/ou Bprobe!=0 é a fonte do B-bus (MBRs/MBRu).
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:30:30 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:30:30 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:30:31 on Aug 23,2025, Elapsed time: 0:06:22
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:30:31 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v5.do =====
Questa Intel FPGA Info: # Testes do MIC-1 (gates) medindo Y/C ANTES do flanco de clock.
Questa Intel FPGA Info: # Inclui ALU lógica (AND/OR), INVA/INC, flags, PC+1, SLL8, SRA1, e writes.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # ULA (Figura 4.2)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     A_AND_B  {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_OR_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus) e Yprobe ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (1) TOS <- 2 (MBRs)  mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) MDR <- 3 (READ)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (4) TOS <- H + MDR => 5  mede ANTES do flanco
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000005 "C = H + MDR"
Questa Intel FPGA Info: # PASS C = H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (5) PC <- 0; depois PC <- PC + 1  mede ANTES do flanco
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1;  step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0   ;# PC=0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula PASS_B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (6) SLL8 (TOS <<= 8)  mede Y pré e C pós-shift ANTES do flanco
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (7) SRA1: -4 >> 1 => -2  mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (8) ALU lógica: A_AND_B
Questa Intel FPGA Info: # H <- 0xF0F0F0F0; MDR <- 0x0FF00FF0 ; Y = H AND MDR = 0x00F000F0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#F0F0F0F0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0FF00FF0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_AND_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00f000f0 "A_AND_B: Y"
Questa Intel FPGA Info: # PASS A_AND_B: Y -> Y=00f000f0
Questa Intel FPGA Info: # expect_c 00f000f0 "A_AND_B: C"
Questa Intel FPGA Info: # PASS A_AND_B: C -> C=00f000f0
Questa Intel FPGA Info: # expect_flags 0 0 "A_AND_B flags"
Questa Intel FPGA Info: # PASS A_AND_B flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (9) ALU lógica: A_OR_B
Questa Intel FPGA Info: # H (fica) = 0xF0F0F0F0; MDR = 0x0000000F ; Y = 0xF0F0F0FF
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0000000F#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_OR_B; run 1 ns
Questa Intel FPGA Info: # expect_y f0f0f0ff "A_OR_B: Y"
Questa Intel FPGA Info: # PASS A_OR_B: Y -> Y=f0f0f0ff
Questa Intel FPGA Info: # expect_c f0f0f0ff "A_OR_B: C"
Questa Intel FPGA Info: # PASS A_OR_B: C -> C=f0f0f0ff
Questa Intel FPGA Info: # expect_flags 0 1 "A_OR_B flags (negativo)"
Questa Intel FPGA Info: # PASS A_OR_B flags (negativo) (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (10) INVA + ADD + INC = (~A)+B+1 (two's complement de A quando B=0)
Questa Intel FPGA Info: # H <- 0 ; B=0 ; INVA=1 ; INC=1 ; Y=0 ; Z deve ser 1
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0   ;# H=0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # Configura add com ENA=1 ENB=0 INVA=1 INC=1
Questa Intel FPGA Info: # force -deposit $TOP/F0 1; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1; force -deposit $TOP/ENB 0
Questa Intel FPGA Info: # force -deposit $TOP/INVA 1; force -deposit $TOP/INC 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "INVA+INC sobre A=0 -> 0"
Questa Intel FPGA Info: # PASS INVA+INC sobre A=0 -> 0 -> Y=00000000
Questa Intel FPGA Info: # expect_c 00000000 "INVA+INC: C"
Questa Intel FPGA Info: # PASS INVA+INC: C -> C=00000000
Questa Intel FPGA Info: # expect_flags 1 0 "INVA+INC flags (zero)"
Questa Intel FPGA Info: # PASS INVA+INC flags (zero) (Z=1 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (11) Flags com MSB=1 (negativo) via PASS_B
Questa Intel FPGA Info: # MDR <- 0x80000000 ; Y = 0x80000000 ; N=1 Z=0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#80000000#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 80000000 "PASS_B negativo: Y"
Questa Intel FPGA Info: # PASS PASS_B negativo: Y -> Y=80000000
Questa Intel FPGA Info: # expect_c 80000000 "PASS_B negativo: C"
Questa Intel FPGA Info: # PASS PASS_B negativo: C -> C=80000000
Questa Intel FPGA Info: # expect_flags 0 1 "PASS_B negativo: flags"
Questa Intel FPGA Info: # PASS PASS_B negativo: flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 319 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v5)  todas as medições feitas ANTES do flanco."
Questa Intel FPGA Info: # >> Testes concluídos (v5)  todas as medições feitas ANTES do flanco.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:34:33 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:34:33 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:34:34 on Aug 23,2025, Elapsed time: 0:04:03
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:34:34 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v6.do =====
Questa Intel FPGA Info: # Ampliação dos testes do MIC-1 (gates) medindo Y/C ANTES do flanco de clock.
Questa Intel FPGA Info: # Adições: MBRs/MBRu, ENB gating, ENA gating, SP+1, writes/reads de LV/CPP/OPC.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # ULA (Figura 4.2)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     A_AND_B  {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_OR_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus) e Yprobe ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (1) TOS <- 2 (MBRs)  mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) MDR <- 3 (READ)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (4) TOS <- H + MDR => 5  mede ANTES do flanco
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000005 "C = H + MDR"
Questa Intel FPGA Info: # PASS C = H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (5) PC <- 0; depois PC <- PC + 1  mede ANTES do flanco
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1;  step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0   ;# PC=0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula PASS_B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (6) SLL8 (TOS <<= 8)  mede Y pré e C pós-shift ANTES do flanco
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (7) SRA1: -4 >> 1 => -2  mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (8) ALU lógica: A_AND_B
Questa Intel FPGA Info: # H <- 0xF0F0F0F0; MDR <- 0x0FF00FF0 ; Y = 0x00F000F0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#F0F0F0F0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0FF00FF0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_AND_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00f000f0 "A_AND_B: Y"
Questa Intel FPGA Info: # PASS A_AND_B: Y -> Y=00f000f0
Questa Intel FPGA Info: # expect_c 00f000f0 "A_AND_B: C"
Questa Intel FPGA Info: # PASS A_AND_B: C -> C=00f000f0
Questa Intel FPGA Info: # expect_flags 0 0 "A_AND_B flags"
Questa Intel FPGA Info: # PASS A_AND_B flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (9) ALU lógica: A_OR_B
Questa Intel FPGA Info: # H (fica)=0xF0F0F0F0; MDR=0x0000000F ; Y=0xF0F0F0FF
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0000000F#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_OR_B; run 1 ns
Questa Intel FPGA Info: # expect_y f0f0f0ff "A_OR_B: Y"
Questa Intel FPGA Info: # PASS A_OR_B: Y -> Y=f0f0f0ff
Questa Intel FPGA Info: # expect_c f0f0f0ff "A_OR_B: C"
Questa Intel FPGA Info: # PASS A_OR_B: C -> C=f0f0f0ff
Questa Intel FPGA Info: # expect_flags 0 1 "A_OR_B flags (negativo)"
Questa Intel FPGA Info: # PASS A_OR_B flags (negativo) (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (10) INVA + ADD + INC = (~A)+B+1 com B=0  -> 0; Z=1
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0   ;# H=0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/F0 1; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1; force -deposit $TOP/ENB 0
Questa Intel FPGA Info: # force -deposit $TOP/INVA 1; force -deposit $TOP/INC 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "INVA+INC sobre A=0 -> 0"
Questa Intel FPGA Info: # PASS INVA+INC sobre A=0 -> 0 -> Y=00000000
Questa Intel FPGA Info: # expect_c 00000000 "INVA+INC: C"
Questa Intel FPGA Info: # PASS INVA+INC: C -> C=00000000
Questa Intel FPGA Info: # expect_flags 1 0 "INVA+INC flags (zero)"
Questa Intel FPGA Info: # PASS INVA+INC flags (zero) (Z=1 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (11) PASS_B com MSB=1 -> N=1, Z=0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#80000000#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 80000000 "PASS_B negativo: Y"
Questa Intel FPGA Info: # PASS PASS_B negativo: Y -> Y=80000000
Questa Intel FPGA Info: # expect_c 80000000 "PASS_B negativo: C"
Questa Intel FPGA Info: # PASS PASS_B negativo: C -> C=80000000
Questa Intel FPGA Info: # expect_flags 0 1 "PASS_B negativo: flags"
Questa Intel FPGA Info: # PASS PASS_B negativo: flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (12) MBRs (sign-extend) vs MBRu (zero-extend) com 0xFF
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#FF#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MBRs (sign-extend 0xFF)"
Questa Intel FPGA Info: # PASS MBRs (sign-extend 0xFF) -> Y=ffffffff
Questa Intel FPGA Info: # expect_c ffffffff "MBRs -> C"
Questa Intel FPGA Info: # PASS MBRs -> C -> C=ffffffff
Questa Intel FPGA Info: # bsel MBRu; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 000000ff "MBRu (zero-extend 0xFF)"
Questa Intel FPGA Info: # PASS MBRu (zero-extend 0xFF) -> Y=000000ff
Questa Intel FPGA Info: # expect_c 000000ff "MBRu -> C"
Questa Intel FPGA Info: # PASS MBRu -> C -> C=000000ff
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (13) ENB gating em PASS_B (B deve zerar quando ENB=0)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0  ;# B=1
Questa Intel FPGA Info: # bsel MDR; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/ENB 0; run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "ENB=0 mascara B (PASS_B)"
Questa Intel FPGA Info: # PASS ENB=0 mascara B (PASS_B) -> Y=00000000
Questa Intel FPGA Info: # force -deposit $TOP/ENB 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ENB=1 libera B (PASS_B)"
Questa Intel FPGA Info: # PASS ENB=1 libera B (PASS_B) -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (14) ENA gating em A_PLUS_B (A deve zerar quando ENA=0)
Questa Intel FPGA Info: # H=1, B=2 -> com ENA=0 sai 2; com ENA=1 sai 3
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0        ;# H=1
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000002#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "A_PLUS_B com ENA=0 (ignora A)"
Questa Intel FPGA Info: # FAIL A_PLUS_B com ENA=0 (ignora A) -> got 00000000 expected 00000002
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000003 "A_PLUS_B com ENA=1 (usa A)"
Questa Intel FPGA Info: # PASS A_PLUS_B com ENA=1 (usa A) -> Y=00000003
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (15) SP <- 0 ; depois SP <- SP + 1 e ler de volta
Questa Intel FPGA Info: # ula ZERO; bsel H; run 1 ns
Questa Intel FPGA Info: # force -deposit $TOP/enSP 1; step 1; force -deposit $TOP/enSP 0                     ;# SP=0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel SP; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = SP + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = SP + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enSP 1; step 1; force -deposit $TOP/enSP 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel SP; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "SP armazenado = 1"
Questa Intel FPGA Info: # PASS SP armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (16) LV write/read (0x12345678)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#12345678#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 12345678 "LV write: Y fonte"
Questa Intel FPGA Info: # PASS LV write: Y fonte -> Y=12345678
Questa Intel FPGA Info: # force -deposit $TOP/enLV 1; step 1; force -deposit $TOP/enLV 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel LV; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 12345678 "LV readback"
Questa Intel FPGA Info: # PASS LV readback -> Y=12345678
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (17) CPP write/read (0xCAFEBABE)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#CAFEBABE#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y cafebabe "CPP write: Y fonte"
Questa Intel FPGA Info: # PASS CPP write: Y fonte -> Y=cafebabe
Questa Intel FPGA Info: # force -deposit $TOP/enCPP 1; step 1; force -deposit $TOP/enCPP 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel CPP; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y cafebabe "CPP readback"
Questa Intel FPGA Info: # PASS CPP readback -> Y=cafebabe
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (18) OPC write/read (0x00000009)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000009#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000009 "OPC write: Y fonte"
Questa Intel FPGA Info: # PASS OPC write: Y fonte -> Y=00000009
Questa Intel FPGA Info: # force -deposit $TOP/enOPC 1; step 1; force -deposit $TOP/enOPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel OPC; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000009 "OPC readback"
Questa Intel FPGA Info: # PASS OPC readback -> Y=00000009
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 477 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v6)  todas as medições ANTES do flanco."
Questa Intel FPGA Info: # >> Testes concluídos (v6)  todas as medições ANTES do flanco.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:38:41 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:38:41 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:38:42 on Aug 23,2025, Elapsed time: 0:04:08
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:38:42 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v6_fix.do =====
Questa Intel FPGA Info: # Testes do MIC-1 (gates) medindo Y/C ANTES do flanco de clock.
Questa Intel FPGA Info: # Adições: diagnósticos no caso A_PLUS_B com ENA=0, leitura de Bprobe/A_H,
Questa Intel FPGA Info: # e matriz de combinações ENA/ENB para isolar bug de mask.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # ULA (Figura 4.2)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B_PLUS_1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     A_AND_B  {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_OR_B   {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ZERO     {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus), Yprobe, Bprobe, A_H ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_BPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set BCANDS [find signals -r $TOP/*Bprobe*]
Questa Intel FPGA Info: # /mic1_draw/ww_Bprobe /mic1_draw/Bprobe
Questa Intel FPGA Info: # if {[llength $BCANDS] > 0} { set BPROBE [lindex $BCANDS 0]; set HAVE_BPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_AH 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set AH_SIG [lindex [find signals -r $TOP/*A_H*] 0]
Questa Intel FPGA Info: # if {$AH_SIG ne ""} { set HAVE_AH 1 }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc show_bus {tag} {
Questa Intel FPGA Info: #   set y ""; set c ""; set b ""; set a ""
Questa Intel FPGA Info: #   if {$::HAVE_YPROBE} { set y [examine -radix hex $::YPROBE] }
Questa Intel FPGA Info: #   if {$::HAVE_CBUS}   { set c [examine -radix hex $::CBUS] }
Questa Intel FPGA Info: #   if {$::HAVE_BPROBE} { set b [examine -radix hex $::BPROBE] }
Questa Intel FPGA Info: #   if {$::HAVE_AH}     { set a [examine -radix hex $::AH_SIG] }
Questa Intel FPGA Info: #   echo "$tag  Y=$y C=$c B=$b A_H=$a"
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (1) TOS <- 2 (MBRs)  mede ANTES do flanco
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000002 "TOS <= 2 (MBRs)"
Questa Intel FPGA Info: # PASS TOS <= 2 (MBRs) -> C=00000002
Questa Intel FPGA Info: # expect_flags 0 0 "TOS=2"
Questa Intel FPGA Info: # PASS TOS=2 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) MDR <- 3 (READ)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#
Questa Intel FPGA Info: # force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) H <- TOS
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (4) TOS <- H + MDR => 5  mede ANTES do flanco
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y = H + MDR"
Questa Intel FPGA Info: # PASS Y = H + MDR -> Y=00000005
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # expect_c 00000005 "C = H + MDR"
Questa Intel FPGA Info: # PASS C = H + MDR -> C=00000005
Questa Intel FPGA Info: # expect_flags 0 0 "Resultado 5"
Questa Intel FPGA Info: # PASS Resultado 5 (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (5) PC <- 0; depois PC <- PC + 1  mede ANTES do flanco
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula PASS_B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (6) SLL8 (TOS <<= 8)
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (7) SRA1: -4 >> 1 => -2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 1; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (8) A_AND_B
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#F0F0F0F0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0FF00FF0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_AND_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00f000f0 "A_AND_B: Y"
Questa Intel FPGA Info: # PASS A_AND_B: Y -> Y=00f000f0
Questa Intel FPGA Info: # expect_c 00f000f0 "A_AND_B: C"
Questa Intel FPGA Info: # PASS A_AND_B: C -> C=00f000f0
Questa Intel FPGA Info: # expect_flags 0 0 "A_AND_B flags"
Questa Intel FPGA Info: # PASS A_AND_B flags (Z=0 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (9) A_OR_B
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0000000F#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_OR_B; run 1 ns
Questa Intel FPGA Info: # expect_y f0f0f0ff "A_OR_B: Y"
Questa Intel FPGA Info: # PASS A_OR_B: Y -> Y=f0f0f0ff
Questa Intel FPGA Info: # expect_c f0f0f0ff "A_OR_B: C"
Questa Intel FPGA Info: # PASS A_OR_B: C -> C=f0f0f0ff
Questa Intel FPGA Info: # expect_flags 0 1 "A_OR_B flags (negativo)"
Questa Intel FPGA Info: # PASS A_OR_B flags (negativo) (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (10) INVA + ADD + INC = (~A)+B+1 com B=0 -> 0; Z=1
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/F0 1; force -deposit $TOP/F1 1
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1; force -deposit $TOP/ENB 0
Questa Intel FPGA Info: # force -deposit $TOP/INVA 1; force -deposit $TOP/INC 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "INVA+INC sobre A=0 -> 0"
Questa Intel FPGA Info: # PASS INVA+INC sobre A=0 -> 0 -> Y=00000000
Questa Intel FPGA Info: # expect_c 00000000 "INVA+INC: C"
Questa Intel FPGA Info: # PASS INVA+INC: C -> C=00000000
Questa Intel FPGA Info: # expect_flags 1 0 "INVA+INC flags (zero)"
Questa Intel FPGA Info: # PASS INVA+INC flags (zero) (Z=1 N=0)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (11) PASS_B negativo
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#80000000#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 80000000 "PASS_B negativo: Y"
Questa Intel FPGA Info: # PASS PASS_B negativo: Y -> Y=80000000
Questa Intel FPGA Info: # expect_c 80000000 "PASS_B negativo: C"
Questa Intel FPGA Info: # PASS PASS_B negativo: C -> C=80000000
Questa Intel FPGA Info: # expect_flags 0 1 "PASS_B negativo: flags"
Questa Intel FPGA Info: # PASS PASS_B negativo: flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (12) MBRs vs MBRu (0xFF)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#FF#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MBRs (sign-extend 0xFF)"
Questa Intel FPGA Info: # PASS MBRs (sign-extend 0xFF) -> Y=ffffffff
Questa Intel FPGA Info: # expect_c ffffffff "MBRs -> C"
Questa Intel FPGA Info: # PASS MBRs -> C -> C=ffffffff
Questa Intel FPGA Info: # bsel MBRu; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 000000ff "MBRu (zero-extend 0xFF)"
Questa Intel FPGA Info: # PASS MBRu (zero-extend 0xFF) -> Y=000000ff
Questa Intel FPGA Info: # expect_c 000000ff "MBRu -> C"
Questa Intel FPGA Info: # PASS MBRu -> C -> C=000000ff
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (13) ENB gating em PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B
Questa Intel FPGA Info: # force -deposit $TOP/ENB 0; run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "ENB=0 mascara B (PASS_B)"
Questa Intel FPGA Info: # PASS ENB=0 mascara B (PASS_B) -> Y=00000000
Questa Intel FPGA Info: # force -deposit $TOP/ENB 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ENB=1 libera B (PASS_B)"
Questa Intel FPGA Info: # PASS ENB=1 libera B (PASS_B) -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (14) *** DIAGNÓSTICO ENA/ENB em A_PLUS_B ***
Questa Intel FPGA Info: # Objetivo: provar que ENA deve apenas zerar A. H=1, B=2.
Questa Intel FPGA Info: # H <- 1
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000001#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # B <- 2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000002#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # show_bus "A_PLUS_B base (ENA=1 ENB=1)"
Questa Intel FPGA Info: # A_PLUS_B base (ENA=1 ENB=1)  Y=00000003 C=00000003 B=00000002 A_H=
Questa Intel FPGA Info: # expect_y 00000003 "A_PLUS_B: ENA=1 ENB=1 -> 1+2=3"
Questa Intel FPGA Info: # PASS A_PLUS_B: ENA=1 ENB=1 -> 1+2=3 -> Y=00000003
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso A: ENA=0 (A mascarado), ENB=1 -> Y deve ser B (=2)
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; run 1 ns
Questa Intel FPGA Info: # show_bus "A_PLUS_B com ENA=0 ENB=1"
Questa Intel FPGA Info: # A_PLUS_B com ENA=0 ENB=1  Y=00000000 C=00000000 B=00000002 A_H=
Questa Intel FPGA Info: # expect_y 00000002 "A_PLUS_B com ENA=0 (ignora A)"
Questa Intel FPGA Info: # FAIL A_PLUS_B com ENA=0 (ignora A) -> got 00000000 expected 00000002
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso B: ENA=1, ENB=0 -> Y deve ser A (=1)
Questa Intel FPGA Info: # force -deposit $TOP/ENA 1; force -deposit $TOP/ENB 0; run 1 ns
Questa Intel FPGA Info: # show_bus "A_PLUS_B com ENA=1 ENB=0"
Questa Intel FPGA Info: # A_PLUS_B com ENA=1 ENB=0  Y=00000000 C=00000000 B=00000002 A_H=
Questa Intel FPGA Info: # expect_y 00000001 "A_PLUS_B com ENB=0 (ignora B)"
Questa Intel FPGA Info: # FAIL A_PLUS_B com ENB=0 (ignora B) -> got 00000000 expected 00000001
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Caso C: ENA=0, ENB=0 -> Y deve ser 0
Questa Intel FPGA Info: # force -deposit $TOP/ENA 0; force -deposit $TOP/ENB 0; run 1 ns
Questa Intel FPGA Info: # show_bus "A_PLUS_B com ENA=0 ENB=0"
Questa Intel FPGA Info: # A_PLUS_B com ENA=0 ENB=0  Y=00000000 C=00000000 B=00000002 A_H=
Questa Intel FPGA Info: # expect_y 00000000 "A_PLUS_B com ENA=0 e ENB=0 (ambos mascarados)"
Questa Intel FPGA Info: # PASS A_PLUS_B com ENA=0 e ENB=0 (ambos mascarados) -> Y=00000000
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Restaura ENB=1 para próximos testes
Questa Intel FPGA Info: # force -deposit $TOP/ENB 1
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (15) SP <- 0 ; depois SP <- SP + 1 e ler de volta
Questa Intel FPGA Info: # ula ZERO; bsel H; run 1 ns
Questa Intel FPGA Info: # force -deposit $TOP/enSP 1; step 1; force -deposit $TOP/enSP 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel SP; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = SP + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = SP + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enSP 1; step 1; force -deposit $TOP/enSP 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel SP; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "SP armazenado = 1"
Questa Intel FPGA Info: # PASS SP armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (16) LV write/read (0x12345678)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#12345678#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 12345678 "LV write: Y fonte"
Questa Intel FPGA Info: # PASS LV write: Y fonte -> Y=12345678
Questa Intel FPGA Info: # force -deposit $TOP/enLV 1; step 1; force -deposit $TOP/enLV 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel LV; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 12345678 "LV readback"
Questa Intel FPGA Info: # PASS LV readback -> Y=12345678
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (17) CPP write/read (0xCAFEBABE)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#CAFEBABE#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y cafebabe "CPP write: Y fonte"
Questa Intel FPGA Info: # PASS CPP write: Y fonte -> Y=cafebabe
Questa Intel FPGA Info: # force -deposit $TOP/enCPP 1; step 1; force -deposit $TOP/enCPP 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel CPP; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y cafebabe "CPP readback"
Questa Intel FPGA Info: # PASS CPP readback -> Y=cafebabe
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (18) OPC write/read (0x00000009)
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000009#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000009 "OPC write: Y fonte"
Questa Intel FPGA Info: # PASS OPC write: Y fonte -> Y=00000009
Questa Intel FPGA Info: # force -deposit $TOP/enOPC 1; step 1; force -deposit $TOP/enOPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel OPC; ula PASS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000009 "OPC readback"
Questa Intel FPGA Info: # PASS OPC readback -> Y=00000009
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 479 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v6_fix)  medições ANTES do flanco + diagnóstico ENA/ENB."
Questa Intel FPGA Info: # >> Testes concluídos (v6_fix)  medições ANTES do flanco + diagnóstico ENA/ENB.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:45:48 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:45:49 on Aug 23,2025, Elapsed time: 0:00:01
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:45:50 on Aug 23,2025, Elapsed time: 0:07:08
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:45:50 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v7.do =====
Questa Intel FPGA Info: # MIC-1 (gates)  mede Y (pré-shifter) e C (pós-shifter) ANTES do flanco de clock.
Questa Intel FPGA Info: # Compatível com a tabela do Tanenbaum (F0 F1 ENA ENB INVA INC)  como no seu RTL.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # ULA conforme tabela Tanenbaum (combinações usadas no seu RTL)
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     A              {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 011000
Questa Intel FPGA Info: #     B              {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 010100
Questa Intel FPGA Info: #     NOT_A          {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0} ;# 011010
Questa Intel FPGA Info: #     NOT_B          {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 101100
Questa Intel FPGA Info: #     A_PLUS_B       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 111100
Questa Intel FPGA Info: #     A_PLUS_B_PLUS1 {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1} ;# 111101
Questa Intel FPGA Info: #     A_PLUS_1       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1} ;# 111001
Questa Intel FPGA Info: #     B_PLUS_1       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1} ;# 110101
Questa Intel FPGA Info: #     B_MINUS_A      {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 1} ;# 111111
Questa Intel FPGA Info: #     B_MINUS_1      {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0} ;# 110110
Questa Intel FPGA Info: #     NEG_A          {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 1} ;# 111011
Questa Intel FPGA Info: #     AND            {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 001100
Questa Intel FPGA Info: #     OR             {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 011100
Questa Intel FPGA Info: #     ZERO           {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0} ;# 010000
Questa Intel FPGA Info: #     ONE            {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1} ;# 110001
Questa Intel FPGA Info: #     MINUS_ONE      {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0} ;# 110010
Questa Intel FPGA Info: #     default        {echo "ula: modo inválido '$mode'"; }
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # localizar C (Cprobe/Cbus) e Yprobe
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # expect helpers
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # util p/ ver buses (opcional)
Questa Intel FPGA Info: # proc _v {s} { if {$s eq ""} {return ""} {return [examine -radix hex $s]} }
Questa Intel FPGA Info: # set BPROBE [lindex [find signals -r $TOP/*Bprobe*] 0]
Questa Intel FPGA Info: # /mic1_draw/ww_Bprobe
Questa Intel FPGA Info: # set AH_SIG [lindex [find signals -r $TOP/*A_H*] 0]
Questa Intel FPGA Info: # proc show_bus {tag} {
Questa Intel FPGA Info: #   echo "$tag  Y=[_v $::YPROBE] C=[_v $::CBUS] B=[_v $::BPROBE] A_H=[_v $::AH_SIG]"
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (1) Construir TOS=5 (2 via MBRs + 3 via MDR)  igual aos testes anteriores
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y=H+MDR (5)"; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # PASS Y=H+MDR (5) -> Y=00000005
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) PC <- 0 ; depois PC <- PC + 1 (mede ANTES do flanco)
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1;  step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) SLL8: mede Y pré / C pós-shift
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/SLL8 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"; clear_ctrl
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (4) SRA1: -4 >> 1 => -2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/SRA1 1; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"; clear_ctrl
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (5) ALU lógica: AND / OR
Questa Intel FPGA Info: # H <- F0F0F0F0 ; MDR <- 0FF00FF0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#F0F0F0F0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0FF00FF0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula AND; run 1 ns
Questa Intel FPGA Info: # expect_y 00f000f0 "AND: Y"; expect_c 00f000f0 "AND: C"; expect_flags 0 0 "AND flags"
Questa Intel FPGA Info: # PASS AND: Y -> Y=00f000f0
Questa Intel FPGA Info: # PASS AND: C -> C=00f000f0
Questa Intel FPGA Info: # PASS AND flags (Z=0 N=0)
Questa Intel FPGA Info: # bsel MDR; ula OR;  run 1 ns
Questa Intel FPGA Info: # expect_y f0f0f0ff "OR: Y";  expect_c f0f0f0ff "OR: C"; expect_flags 0 1 "OR flags (negativo)"
Questa Intel FPGA Info: # FAIL OR: Y -> got fff0fff0 expected f0f0f0ff
Questa Intel FPGA Info: # FAIL OR: C -> got fff0fff0 expected f0f0f0ff
Questa Intel FPGA Info: # PASS OR flags (negativo) (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (6) Constantes ZERO / ONE / MINUS_ONE
Questa Intel FPGA Info: # ula ZERO; run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "ZERO"; expect_c 00000000 "ZERO C"; expect_flags 1 0 "ZERO flags"
Questa Intel FPGA Info: # PASS ZERO -> Y=00000000
Questa Intel FPGA Info: # PASS ZERO C -> C=00000000
Questa Intel FPGA Info: # PASS ZERO flags (Z=1 N=0)
Questa Intel FPGA Info: # ula ONE; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ONE";  expect_c 00000001 "ONE C";  expect_flags 0 0 "ONE flags"
Questa Intel FPGA Info: # PASS ONE -> Y=00000001
Questa Intel FPGA Info: # PASS ONE C -> C=00000001
Questa Intel FPGA Info: # PASS ONE flags (Z=0 N=0)
Questa Intel FPGA Info: # ula MINUS_ONE; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MINUS_ONE"; expect_c ffffffff "MINUS_ONE C"; expect_flags 0 1 "MINUS_ONE flags"
Questa Intel FPGA Info: # PASS MINUS_ONE -> Y=ffffffff
Questa Intel FPGA Info: # PASS MINUS_ONE C -> C=ffffffff
Questa Intel FPGA Info: # PASS MINUS_ONE flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (7) Passes e complementos segundo a tabela
Questa Intel FPGA Info: # Preparar A=H=0000000A, B=MDR=00000003
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0000000A#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0     ;# A=10
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0 ;# B=3
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # bsel MDR; ula A; run 1 ns        ;# A
Questa Intel FPGA Info: # expect_y 0000000a "A (011000)"
Questa Intel FPGA Info: # PASS A (011000) -> Y=0000000a
Questa Intel FPGA Info: # bsel MDR; ula B; run 1 ns        ;# B
Questa Intel FPGA Info: # expect_y 00000003 "B (010100)"
Questa Intel FPGA Info: # PASS B (010100) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula NOT_A; run 1 ns
Questa Intel FPGA Info: # expect_y fffffff5 "NOT A (011010)"
Questa Intel FPGA Info: # PASS NOT A (011010) -> Y=fffffff5
Questa Intel FPGA Info: # bsel MDR; ula NOT_B; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "NOT B (101100)"
Questa Intel FPGA Info: # PASS NOT B (101100) -> Y=fffffffc
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (8) Aritmética segundo a tabela
Questa Intel FPGA Info: # A=H=00000002 ; B=MDR=00000005
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000002#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0     ;# A=2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000005#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0 ;# B=5
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B;       run 1 ns; expect_y 00000007 "A+B (111100)"
Questa Intel FPGA Info: # PASS A+B (111100) -> Y=00000007
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B_PLUS1; run 1 ns; expect_y 00000008 "A+B+1 (111101)"
Questa Intel FPGA Info: # PASS A+B+1 (111101) -> Y=00000008
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_1;       run 1 ns; expect_y 00000003 "A+1 (111001)"
Questa Intel FPGA Info: # PASS A+1 (111001) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula B_PLUS_1;       run 1 ns; expect_y 00000006 "B+1 (110101)"
Questa Intel FPGA Info: # PASS B+1 (110101) -> Y=00000006
Questa Intel FPGA Info: # bsel MDR; ula B_MINUS_A;      run 1 ns; expect_y 00000003 "B-A (111111)"
Questa Intel FPGA Info: # PASS B-A (111111) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula B_MINUS_1;      run 1 ns; expect_y 00000004 "B-1 (110110)"
Questa Intel FPGA Info: # PASS B-1 (110110) -> Y=00000004
Questa Intel FPGA Info: # bsel MDR; ula NEG_A;          run 1 ns; expect_y fffffffe "-A (111011)"
Questa Intel FPGA Info: # PASS -A (111011) -> Y=fffffffe
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (9) MBRs vs MBRu (0xFF)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#FF#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MBRs (sign-extend 0xFF)"; expect_c ffffffff "MBRs -> C"
Questa Intel FPGA Info: # PASS MBRs (sign-extend 0xFF) -> Y=ffffffff
Questa Intel FPGA Info: # PASS MBRs -> C -> C=ffffffff
Questa Intel FPGA Info: # bsel MBRu; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y 000000ff "MBRu (zero-extend 0xFF)"; expect_c 000000ff "MBRu -> C"
Questa Intel FPGA Info: # PASS MBRu (zero-extend 0xFF) -> Y=000000ff
Questa Intel FPGA Info: # PASS MBRu -> C -> C=000000ff
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 376 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v7)  todos alinhados com a tabela do Tanenbaum e medidos ANTES do flanco."
Questa Intel FPGA Info: # >> Testes concluídos (v7)  todos alinhados com a tabela do Tanenbaum e medidos ANTES do flanco.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: do MIC_1_run_msim_gate_vhdl.do
Questa Intel FPGA Info: # if {[file exists gate_work]} {
Questa Intel FPGA Info: # 	vdel -lib gate_work -all
Questa Intel FPGA Info: # }
Questa Intel FPGA Warning: # ** Warning: (vdel-134) Unable to remove locked optimized design "_opt".  Locker is luizhengs@luizhengs-IdeaPad-3-15ALC6.
Questa Intel FPGA Info: # vlib gate_work
Questa Intel FPGA Warning: # ** Warning: (vlib-34) Library already exists at "gate_work".
Questa Intel FPGA Info: # Errors: 0, Warnings: 1
Questa Intel FPGA Info: # vmap work gate_work
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vmap 2024.3 Lib Mapping Utility 2024.09 Sep 10 2024
Questa Intel FPGA Info: # vmap work gate_work 
Questa Intel FPGA Info: # Modifying modelsim.ini
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # vcom -93 -work work {MIC_1.vho}
Questa Intel FPGA Info: # Questa Intel Starter FPGA Edition-64 vcom 2024.3 Compiler 2024.09 Sep 10 2024
Questa Intel FPGA Info: # Start time: 23:50:43 on Aug 23,2025
Questa Intel FPGA Info: # vcom -reportprogress 300 -93 -work work MIC_1.vho 
Questa Intel FPGA Info: # -- Loading package STANDARD
Questa Intel FPGA Info: # -- Loading package TEXTIO
Questa Intel FPGA Info: # -- Loading package std_logic_1164
Questa Intel FPGA Info: # -- Loading package VITAL_Timing
Questa Intel FPGA Info: # -- Loading package VITAL_Primitives
Questa Intel FPGA Info: # -- Loading package dffeas_pack
Questa Intel FPGA Info: # -- Loading package altera_primitives_components
Questa Intel FPGA Info: # -- Loading package altera_lnsim_components
Questa Intel FPGA Info: # -- Loading package cyclonev_atom_pack
Questa Intel FPGA Info: # -- Loading package cyclonev_components
Questa Intel FPGA Info: # -- Compiling entity mic1_draw
Questa Intel FPGA Info: # -- Compiling architecture structure of mic1_draw
Questa Intel FPGA Info: # End time: 23:50:43 on Aug 23,2025, Elapsed time: 0:00:00
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # End time: 23:50:43 on Aug 23,2025, Elapsed time: 0:04:53
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Questa Intel FPGA Info: # vsim -t ns work.mic1_draw 
Questa Intel FPGA Info: # Start time: 23:50:43 on Aug 23,2025
Questa Intel FPGA Info: # ** Note: (vsim-8009) Loading existing optimized design _opt
Questa Intel FPGA Info: # Loading std.standard
Questa Intel FPGA Info: # Loading std.textio(body)
Questa Intel FPGA Info: # Loading ieee.std_logic_1164(body)
Questa Intel FPGA Info: # Loading ieee.vital_timing(body)
Questa Intel FPGA Info: # Loading ieee.vital_primitives(body)
Questa Intel FPGA Info: # Loading altera.dffeas_pack
Questa Intel FPGA Info: # Loading altera.altera_primitives_components
Questa Intel FPGA Info: # Loading altera_lnsim.altera_lnsim_components
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_atom_pack(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_components
Questa Intel FPGA Info: # Loading work.mic1_draw(structure)#1
Questa Intel FPGA Info: # Loading ieee.std_logic_arith(body)
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_obuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_io_ibuf(arch)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#347
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#219
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#346
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#7
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#1
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#342
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#10
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#363
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#14
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#43
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#142
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#18
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#358
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#2
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#22
Questa Intel FPGA Info: # Loading altera.dffeas(vital_dffeas)#3
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#288
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#115
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#28
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#29
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#41
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#91
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#327
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#36
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#259
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#44
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#292
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#61
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#64
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#216
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#340
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#318
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#333
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#85
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#233
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#89
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#339
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#102
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#124
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#184
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#185
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#190
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#364
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#198
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#338
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#251
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#254
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#266
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#348
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#269
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#270
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#272
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#291
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#353
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#362
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#357
Questa Intel FPGA Info: # Loading cyclonev.cyclonev_lcell_comb(vital_lcell_comb)#365
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) (opcional) agrupar as ondas
Questa Intel FPGA Info: # do group_waves.do
Questa Intel FPGA Info: # ======= group_waves.do (com Yprobe/Bprobe/Cprobe) =======
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw   ;# troque se seu topo tiver outro nome
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # quietly WaveActivateNextPane {} 0
Questa Intel FPGA Info: # view wave
Questa Intel FPGA Info: # .main_pane.wave.interior.cs.body.pw.wf
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Aparência
Questa Intel FPGA Info: # configure wave -namecolwidth 260
Questa Intel FPGA Info: # configure wave -valuecolwidth 120
Questa Intel FPGA Info: # configure wave -justifyvalue left
Questa Intel FPGA Info: # configure wave -signalnamewidth 1
Questa Intel FPGA Info: # configure wave -timelineunits ns
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Clock e Reset
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/clk
Questa Intel FPGA Info: # add wave -noupdate -group {CLK_RST} $TOP/rst
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Enables (escrita no C-bus)
Questa Intel FPGA Info: # add wave -noupdate -group {EN_writeC} $TOP/enH $TOP/enOPC $TOP/enTOS $TOP/enCPP \
Questa Intel FPGA Info: #                                    $TOP/enLV $TOP/enSP  $TOP/enPC  $TOP/enMDR $TOP/enMAR
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) BSEL one-hot (com rótulos)
Questa Intel FPGA Info: # foreach {label idx} {B_H 0 B_PC 1 B_MDR 2 B_MBRs 3 B_MBRu 4 B_SP 5 B_LV 6 B_CPP 7 B_TOS 8 B_OPC 9} {
Questa Intel FPGA Info: #   if {[llength [find signals $TOP/bsel_oh\($idx\)]]} {
Questa Intel FPGA Info: #     add wave -noupdate -group {BSEL_onehot} -radix binary -label $label $TOP/bsel_oh\($idx\)
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 4) ULA
Questa Intel FPGA Info: # add wave -noupdate -group {ULA_ctrl} $TOP/F0 $TOP/F1 $TOP/ENA $TOP/ENB $TOP/INVA $TOP/INC
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 5) Shifter
Questa Intel FPGA Info: # add wave -noupdate -group {SHIFTER} $TOP/SLL8 $TOP/SRA1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 6) Interface "memória"
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} $TOP/FETCH $TOP/READ
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MBR_in
Questa Intel FPGA Info: # add wave -noupdate -group {MEM_IF} -radix hex $TOP/MDR_in
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 7) Flags
Questa Intel FPGA Info: # add wave -noupdate -group {FLAGS} $TOP/Z $TOP/N
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 8) BUSES  tenta pinos/sondas
Questa Intel FPGA Info: # proc _add_first {pattern group radix} {
Questa Intel FPGA Info: #   set L [find signals -r $pattern]
Questa Intel FPGA Info: #   if {[llength $L] > 0} { add wave -noupdate -group $group -radix $radix [lindex $L 0] }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # _add_first "$TOP/*A_H*"    BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cbus*"   BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Bprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Cprobe*" BUSES hex
Questa Intel FPGA Info: # _add_first "$TOP/*Yprobe*" BUSES hex
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 837 ns
Questa Intel FPGA Info: # echo ">> group_waves: pronto."
Questa Intel FPGA Info: # >> group_waves: pronto.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) aplicar os estímulos (2+3, PC+1, SLL8, SRA1&)
Questa Intel FPGA Info: # do stim_debug_y.do
Questa Intel FPGA Info: # ===== stim_debug_y.do =====
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Relógio 10 ns (50% duty)
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 {5 ns} -repeat {10 ns}
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Helpers
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run 10 ns } }
Questa Intel FPGA Info: # proc bsel_none {} { for {set i 0} {$i<10} {incr i} { force -deposit sim:/mic1_draw/bsel_oh($i) 0 } }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit sim:/mic1_draw/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     PASS_B   {force -deposit sim:/mic1_draw/F0 0; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 0; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B {force -deposit sim:/mic1_draw/F0 1; force -deposit sim:/mic1_draw/F1 1; force -deposit sim:/mic1_draw/ENA 1; force -deposit sim:/mic1_draw/ENB 1; force -deposit sim:/mic1_draw/INVA 0; force -deposit sim:/mic1_draw/INC 0}
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Monta TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#; force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula PASS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula PASS_B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel_none
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Seleciona TOS no B-bus e deixa ULA em PASS_B
Questa Intel FPGA Info: # bsel TOS; ula PASS_B
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Descobre os pinos/sondas
Questa Intel FPGA Info: # set YSIG [lindex [concat [find signals -r $TOP/*Yprobe*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Yprobe
Questa Intel FPGA Info: # set CSIG [lindex [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]] 0]
Questa Intel FPGA Info: # /mic1_draw/Cprobe
Questa Intel FPGA Info: # puts ">> Usando Y=$YSIG   C=$CSIG"
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 1) Antes do shift
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y0 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c0 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # echo "ANTES:  Y=$y0   C=$c0   (esperado: Y=00000005, C=00000005)"
Questa Intel FPGA Info: # ANTES:  Y=00000005   C=00000005   (esperado: Y=00000005, C=00000005)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 2) Liga SLL8
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 1
Questa Intel FPGA Info: # run 1 ns
Questa Intel FPGA Info: # set y1 [examine -radix hex $YSIG]
Questa Intel FPGA Info: # 00000005
Questa Intel FPGA Info: # set c1 [examine -radix hex $CSIG]
Questa Intel FPGA Info: # 00000500
Questa Intel FPGA Info: # echo "DEPOIS: Y=$y1   C=$c1   (esperado: Y=00000005, C=00000500)"
Questa Intel FPGA Info: # DEPOIS: Y=00000005   C=00000500   (esperado: Y=00000005, C=00000500)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 3) Quem dirige essas nets?  (comando correto no Questa)
Questa Intel FPGA Info: # if {$YSIG ne ""} { echo "Drivers de Y:"; drivers $YSIG }
Questa Intel FPGA Info: # Drivers de Y:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Yprobe(31:0):
Questa Intel FPGA Info: #    32'h00000005  : Signal /mic1_draw/Yprobe
Questa Intel FPGA Info: #      32'h00000005 : Driver /mic1_draw/line__1600
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # if {$CSIG ne ""} { echo "Drivers de C:"; drivers $CSIG }
Questa Intel FPGA Info: # Drivers de C:
Questa Intel FPGA Info: # Drivers for /mic1_draw/Cprobe(31:0):
Questa Intel FPGA Info: #    32'h00000500  : Signal /mic1_draw/Cprobe
Questa Intel FPGA Info: #      32'h00000500 : Driver /mic1_draw/line__1599
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # do stim_mic1_gate.do
Questa Intel FPGA Info: # ===== stim_mic1_gate_v7.do =====
Questa Intel FPGA Info: # Testes MIC-1 (pós-synth) medindo Y/C **ANTES** do flanco de clock.
Questa Intel FPGA Info: # Alinhado à Figura 4.2 (Tanenbaum 6ª ed.). Inclui PC+1, SLL8, SRA1,
Questa Intel FPGA Info: # lógicas AND/OR, constantes, passes/complementos e aritmética.
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # onerror {resume}
Questa Intel FPGA Info: # set TOP sim:/mic1_draw
Questa Intel FPGA Info: # sim:/mic1_draw
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- relógio 10 ns (50% duty) ----
Questa Intel FPGA Info: # set T  "10 ns"
Questa Intel FPGA Info: # 10 ns
Questa Intel FPGA Info: # set TH "5 ns"
Questa Intel FPGA Info: # 5 ns
Questa Intel FPGA Info: # force -freeze $TOP/clk 0 0, 1 $TH -repeat $T
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- helpers ----
Questa Intel FPGA Info: # proc step {n} { for {set i 0} {$i<$n} {incr i} { run $::T } }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc bsel_none {} {
Questa Intel FPGA Info: #   for {set i 0} {$i<10} {incr i} { force -deposit $::TOP/bsel_oh($i) 0 }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc bsel {src} {
Questa Intel FPGA Info: #   array set IDX {H 0 PC 1 MDR 2 MBRs 3 MBRu 4 SP 5 LV 6 CPP 7 TOS 8 OPC 9}
Questa Intel FPGA Info: #   if {![info exists IDX($src)]} { echo "bsel: fonte '$src' inválida"; return }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: #   force -deposit $::TOP/bsel_oh($IDX($src)) 1
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc clear_ctrl {} {
Questa Intel FPGA Info: #   foreach s {enH enOPC enTOS enCPP enLV enSP enPC enMDR enMAR F0 F1 ENA ENB INVA INC SLL8 SRA1 FETCH READ} {
Questa Intel FPGA Info: #     force -deposit $::TOP/$s 0
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: #   bsel_none
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- ULA (mapa exato da Figura 4.2) ----
Questa Intel FPGA Info: # F0 F1 ENA ENB INVA INC
Questa Intel FPGA Info: # proc ula {mode} {
Questa Intel FPGA Info: #   switch -exact -- $mode {
Questa Intel FPGA Info: #     A               {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     B               {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     NOT_A           {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     NOT_B           {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B        {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     A_PLUS_B_PLUS1  {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     A_PLUS_1        {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     B_PLUS_1        {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     B_MINUS_A       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     B_MINUS_1       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     NEG_A           {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     AND             {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 0; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     OR              {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 1; force -deposit $::TOP/ENB 1; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ZERO            {force -deposit $::TOP/F0 0; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     ONE             {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 0; force -deposit $::TOP/INC 1}
Questa Intel FPGA Info: #     MINUS_ONE       {force -deposit $::TOP/F0 1; force -deposit $::TOP/F1 1; force -deposit $::TOP/ENA 0; force -deposit $::TOP/ENB 0; force -deposit $::TOP/INVA 1; force -deposit $::TOP/INC 0}
Questa Intel FPGA Info: #     default         {echo "ula: modo desconhecido '$mode'"; }
Questa Intel FPGA Info: #   }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ---- localizar C (Cprobe/Cbus) e Yprobe ----
Questa Intel FPGA Info: # set HAVE_CBUS 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set CANDS [concat [find signals -r $TOP/*Cprobe*] [find signals -r $TOP/*Cbus*]]
Questa Intel FPGA Info: # /mic1_draw/Cprobe /mic1_draw/ww_Cprobe
Questa Intel FPGA Info: # if {[llength $CANDS] > 0} { set CBUS [lindex $CANDS 0]; set HAVE_CBUS 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # set HAVE_YPROBE 0
Questa Intel FPGA Info: # 0
Questa Intel FPGA Info: # set YCANDS [find signals -r $TOP/*Yprobe*]
Questa Intel FPGA Info: # /mic1_draw/Yprobe /mic1_draw/ww_Yprobe
Questa Intel FPGA Info: # if {[llength $YCANDS] > 0} { set YPROBE [lindex $YCANDS 0]; set HAVE_YPROBE 1 }
Questa Intel FPGA Info: # 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # proc _hexnorm {h} { return [string tolower [string map -nocase {16# "" # ""} $h]] }
Questa Intel FPGA Info: # proc expect_c {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_CBUS} { echo "SKIP (Cbus não visível): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::CBUS]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> C=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_y {hex msg} {
Questa Intel FPGA Info: #   if {!$::HAVE_YPROBE} { echo "SKIP (Yprobe não exposto): $msg"; return }
Questa Intel FPGA Info: #   set v [string tolower [examine -radix hex $::YPROBE]]
Questa Intel FPGA Info: #   set e [_hexnorm $hex]
Questa Intel FPGA Info: #   if {$v eq $e} { echo "PASS $msg -> Y=$v" } else { echo "FAIL $msg -> got $v expected $e" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # proc expect_flags {zexp nexp msg} {
Questa Intel FPGA Info: #   set z [examine $::TOP/Z]; set n [examine $::TOP/N]
Questa Intel FPGA Info: #   if {$z eq $zexp && $n eq $nexp} { echo "PASS $msg (Z=$z N=$n)" } \
Questa Intel FPGA Info: #   else { echo "FAIL $msg (Z=$z N=$n) expected (Z=$zexp N=$nexp)" }
Questa Intel FPGA Info: # }
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # ===================== SEQUÊNCIA =====================
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # Reset
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # force -deposit $TOP/rst 1; step 2
Questa Intel FPGA Info: # force -deposit $TOP/rst 0; step 1
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (1) Construir TOS=5 (2 via MBRs + 3 via MDR)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#02#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000002 "Y=MBRs"; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # PASS Y=MBRs -> Y=00000002
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y=H+MDR (5)"; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # PASS Y=H+MDR (5) -> Y=00000005
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (2) PC <- 0 ; depois PC <- PC + 1 (mede ANTES do flanco)
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enH 1;  step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # ula ZERO; bsel H; force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B_PLUS_1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "Y = PC + 1 (combinacional)"
Questa Intel FPGA Info: # PASS Y = PC + 1 (combinacional) -> Y=00000001
Questa Intel FPGA Info: # force -deposit $TOP/enPC 1; step 1; force -deposit $TOP/enPC 0
Questa Intel FPGA Info: # clear_ctrl; run 1 ns
Questa Intel FPGA Info: # bsel PC; ula B; run 1 ns; expect_y 00000001 "PC armazenado = 1"
Questa Intel FPGA Info: # PASS PC armazenado = 1 -> Y=00000001
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (3) SLL8: mede Y pré / C pós-shift
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/SLL8 1; run 1 ns
Questa Intel FPGA Info: # expect_y 00000005 "Y antes do shift (TOS=5)"
Questa Intel FPGA Info: # PASS Y antes do shift (TOS=5) -> Y=00000005
Questa Intel FPGA Info: # expect_c 00000500 "C depois do shift (5<<8)"
Questa Intel FPGA Info: # PASS C depois do shift (5<<8) -> C=00000500
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SLL8 0
Questa Intel FPGA Info: # expect_flags 0 0 "SLL8 flags"; clear_ctrl
Questa Intel FPGA Info: # PASS SLL8 flags (Z=0 N=0)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (4) SRA1: -4 >> 1 => -2
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#FFFFFFFC#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # bsel TOS; ula B; force -deposit $TOP/SRA1 1; run 1 ns
Questa Intel FPGA Info: # expect_y fffffffc "Y antes do shift (-4)"
Questa Intel FPGA Info: # PASS Y antes do shift (-4) -> Y=fffffffc
Questa Intel FPGA Info: # expect_c fffffffe "C depois do shift (-4>>1)"
Questa Intel FPGA Info: # PASS C depois do shift (-4>>1) -> C=fffffffe
Questa Intel FPGA Info: # force -deposit $TOP/enTOS 1; step 1; force -deposit $TOP/enTOS 0
Questa Intel FPGA Info: # force -deposit $TOP/SRA1 0
Questa Intel FPGA Info: # expect_flags 0 1 "SRA1 flags"; clear_ctrl
Questa Intel FPGA Info: # PASS SRA1 flags (Z=0 N=1)
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (5) ALU lógica: AND / OR
Questa Intel FPGA Info: # H <- F0F0F0F0 ; MDR <- 0FF00FF0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#F0F0F0F0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0FF00FF0#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula AND; run 1 ns
Questa Intel FPGA Info: # expect_y 00f000f0 "AND: Y"; expect_c 00f000f0 "AND: C"; expect_flags 0 0 "AND flags"
Questa Intel FPGA Info: # PASS AND: Y -> Y=00f000f0
Questa Intel FPGA Info: # PASS AND: C -> C=00f000f0
Questa Intel FPGA Info: # PASS AND flags (Z=0 N=0)
Questa Intel FPGA Info: # bsel MDR; ula OR;  run 1 ns
Questa Intel FPGA Info: # CORREÇÃO: OR correto com A=F0F0F0F0, B=0FF00FF0 é FFF0FFF0
Questa Intel FPGA Info: # expect_y fff0fff0 "OR: Y";  expect_c fff0fff0 "OR: C"; expect_flags 0 1 "OR flags (negativo)"
Questa Intel FPGA Info: # PASS OR: Y -> Y=fff0fff0
Questa Intel FPGA Info: # PASS OR: C -> C=fff0fff0
Questa Intel FPGA Info: # PASS OR flags (negativo) (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (6) Constantes ZERO / ONE / MINUS_ONE
Questa Intel FPGA Info: # ula ZERO; run 1 ns
Questa Intel FPGA Info: # expect_y 00000000 "ZERO"; expect_c 00000000 "ZERO C"; expect_flags 1 0 "ZERO flags"
Questa Intel FPGA Info: # PASS ZERO -> Y=00000000
Questa Intel FPGA Info: # PASS ZERO C -> C=00000000
Questa Intel FPGA Info: # PASS ZERO flags (Z=1 N=0)
Questa Intel FPGA Info: # ula ONE; run 1 ns
Questa Intel FPGA Info: # expect_y 00000001 "ONE";  expect_c 00000001 "ONE C";  expect_flags 0 0 "ONE flags"
Questa Intel FPGA Info: # PASS ONE -> Y=00000001
Questa Intel FPGA Info: # PASS ONE C -> C=00000001
Questa Intel FPGA Info: # PASS ONE flags (Z=0 N=0)
Questa Intel FPGA Info: # ula MINUS_ONE; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MINUS_ONE"; expect_c ffffffff "MINUS_ONE C"; expect_flags 0 1 "MINUS_ONE flags"
Questa Intel FPGA Info: # PASS MINUS_ONE -> Y=ffffffff
Questa Intel FPGA Info: # PASS MINUS_ONE C -> C=ffffffff
Questa Intel FPGA Info: # PASS MINUS_ONE flags (Z=0 N=1)
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (7) Passes e complementos
Questa Intel FPGA Info: # A=H=0000000A, B=MDR=00000003
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#0000000A#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000003#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A;      run 1 ns; expect_y 0000000a "A (011000)"
Questa Intel FPGA Info: # PASS A (011000) -> Y=0000000a
Questa Intel FPGA Info: # bsel MDR; ula B;      run 1 ns; expect_y 00000003 "B (010100)"
Questa Intel FPGA Info: # PASS B (010100) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula NOT_A;  run 1 ns; expect_y fffffff5 "NOT A (011010)"
Questa Intel FPGA Info: # PASS NOT A (011010) -> Y=fffffff5
Questa Intel FPGA Info: # bsel MDR; ula NOT_B;  run 1 ns; expect_y fffffffc "NOT B (101100)"
Questa Intel FPGA Info: # PASS NOT B (101100) -> Y=fffffffc
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (8) Aritmética
Questa Intel FPGA Info: # A=H=00000002 ; B=MDR=00000005
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000002#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula B; force -deposit $TOP/enH 1; step 1; force -deposit $TOP/enH 0
Questa Intel FPGA Info: # force -deposit $TOP/MDR_in 16#00000005#; force -deposit $TOP/READ 1; step 1; force -deposit $TOP/READ 0
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B;       run 1 ns; expect_y 00000007 "A+B (111100)"
Questa Intel FPGA Info: # PASS A+B (111100) -> Y=00000007
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_B_PLUS1; run 1 ns; expect_y 00000008 "A+B+1 (111101)"
Questa Intel FPGA Info: # PASS A+B+1 (111101) -> Y=00000008
Questa Intel FPGA Info: # bsel MDR; ula A_PLUS_1;       run 1 ns; expect_y 00000003 "A+1 (111001)"
Questa Intel FPGA Info: # PASS A+1 (111001) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula B_PLUS_1;       run 1 ns; expect_y 00000006 "B+1 (110101)"
Questa Intel FPGA Info: # PASS B+1 (110101) -> Y=00000006
Questa Intel FPGA Info: # bsel MDR; ula B_MINUS_A;      run 1 ns; expect_y 00000003 "B-A (111111)"
Questa Intel FPGA Info: # PASS B-A (111111) -> Y=00000003
Questa Intel FPGA Info: # bsel MDR; ula B_MINUS_1;      run 1 ns; expect_y 00000004 "B-1 (110110)"
Questa Intel FPGA Info: # PASS B-1 (110110) -> Y=00000004
Questa Intel FPGA Info: # bsel MDR; ula NEG_A;          run 1 ns; expect_y fffffffe "-A (111011)"
Questa Intel FPGA Info: # PASS -A (111011) -> Y=fffffffe
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # (9) MBRs vs MBRu (0xFF)
Questa Intel FPGA Info: # force -deposit $TOP/MBR_in 16#FF#
Questa Intel FPGA Info: # force -deposit $TOP/FETCH 1; step 1; force -deposit $TOP/FETCH 0
Questa Intel FPGA Info: # bsel MBRs; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y ffffffff "MBRs (sign-extend 0xFF)"; expect_c ffffffff "MBRs -> C"
Questa Intel FPGA Info: # PASS MBRs (sign-extend 0xFF) -> Y=ffffffff
Questa Intel FPGA Info: # PASS MBRs -> C -> C=ffffffff
Questa Intel FPGA Info: # bsel MBRu; ula B; run 1 ns
Questa Intel FPGA Info: # expect_y 000000ff "MBRu (zero-extend 0xFF)"; expect_c 000000ff "MBRu -> C"
Questa Intel FPGA Info: # PASS MBRu (zero-extend 0xFF) -> Y=000000ff
Questa Intel FPGA Info: # PASS MBRu -> C -> C=000000ff
Questa Intel FPGA Info: # clear_ctrl
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # update
Questa Intel FPGA Info: # wave zoomfull
Questa Intel FPGA Info: # 0 ns
Questa Intel FPGA Info: # 376 ns
Questa Intel FPGA Info: # echo ">> Testes concluídos (v7)  todos alinhados com a tabela do Tanenbaum e medidos ANTES do flanco."
Questa Intel FPGA Info: # >> Testes concluídos (v7)  todos alinhados com a tabela do Tanenbaum e medidos ANTES do flanco.
Questa Intel FPGA Info: # ===== fim =====
Questa Intel FPGA Info: # 
Questa Intel FPGA Info: # run 2 us
Questa Intel FPGA Info: # End time: 23:55:02 on Aug 23,2025, Elapsed time: 0:04:19
Questa Intel FPGA Info: # Errors: 0, Warnings: 0
Error: Errors encountered while running modelsim do file
Error: NativeLink simulation flow was NOT successful



================The following additional information is provided to help identify the cause of error while running nativelink scripts=================
Nativelink TCL script failed with errorCode:  1
Nativelink TCL script failed with errorInfo:  1
    (procedure "launch_sim" line 1)
    invoked from within
"launch_sim launch_args_hash"
    ("eval" body line 1)
    invoked from within
"eval launch_sim launch_args_hash"
    invoked from within
"if [ info exists ::errorCode ] {
                set savedCode $::errorCode
                set savedInfo $::errorInfo
                error $result $..."
    invoked from within
"if [catch {eval launch_sim launch_args_hash} result ] {
            set status 1
            if [ info exists ::errorCode ] {
                set save..."
    (procedure "run_sim" line 74)
    invoked from within
"run_sim run_sim_args_hash"
    invoked from within
"if [ info exists ::errorCode ] {
            set savedCode $::errorCode
            set savedInfo $::errorInfo
            error "$result" $savedInfo ..."
    (procedure "run_eda_simulation_tool" line 334)
    invoked from within
"run_eda_simulation_tool eda_opts_hash"
